{"version":3,"sources":["../src/node.ts","../src/zipper.ts"],"sourcesContent":["export type Node<T> = {\n  readonly value: T,\n  readonly children: Array<Node<T>>\n}\n\nexport function singleton<T> (value: T): Node<T> {\n  return { value, children: [] }\n}\n\nexport function node<T> (value: T, children: Array<Node<T>>): Node<T> {\n  return { value, children }\n}\n\nexport function isLeaf<T> ({ children }: Node<T>): boolean {\n  return children.length == 0\n}\n\nexport function hasChildren<T> ({ children }: Node<T>) : boolean {\n  return children.length > 0\n}\n\nexport function appendChild<T> (child: Node<T>, { value, children }: Node<T>) : Node<T> {\n  return { value, children: [...children, child] }\n}\n\nexport function prependChild<T> (child: Node<T>, { value, children }: Node<T>) : Node<T> {\n  return { value, children: [child, ...children] }\n}\n\nexport function mapValue<T> (\n  fn: (v: T) => T,\n  { value, children }: Node<T>\n): Node<T> {\n  return { value: fn(value), children }\n}\n\nexport function replaceValue<T> (value: T, { children }: Node<T>): Node<T> {\n  return { value, children }\n}\n\nexport function foldr<T,U> (\n  fn: (value: T, acc: U) => U,\n  acc: U,\n  seed: Node<T>\n): U {\n  const list = foldl((a: T, b: Array<T>) => [a, ...b], [], seed)\n  return list.reduce((a, v) => fn(v, a), acc)\n}\n\nexport function foldl<T, U> (\n  fn: (value: T, acc: U) => U,\n  acc: U,\n  seed: Node<T>\n): U {\n\n  return foldStep(fn, acc, [seed], [])\n}\n\nexport function foldStep<T, U> (\n  fn: (value: T, acc: U) => U,\n  acc: U,\n  nodes: Array<Node<T>>,\n  sets: Array<Array<Node<T>>>\n): U {\n  const [cursor, ...rest] = nodes\n  if (cursor) {\n    const { value, children } = cursor\n    if (children.length > 0) return foldStep(fn, fn(value, acc), children, [rest, ...sets])\n    else return foldStep(fn, fn(value, acc), rest, sets)\n  }\n  else if (sets.length > 0) {\n    const [head , ...tails] = sets\n    return foldStep(fn, acc, head, tails)\n  }\n  else return acc\n}\n\nexport function count<T> (tree: Node<T>): number {\n  return foldl((_value, sum) => sum + 1, 0, tree)\n}\n","import { type Node, mapValue, singleton } from './node'\n\nexport type Context<T> = {\n  readonly focus: T,\n  readonly left: Array<Node<T>>,\n  readonly right: Array<Node<T>>\n}\n\nexport type Zipper<T> = {\n  readonly node: Node<T>\n  readonly path: Array<Context<T>>\n}\n\nexport function zipper<T> (node: Node<T>): Zipper<T> {\n  return { node: node, path: [] }\n}\n\nexport function update<T> (fn: (value: T) => T, { node, path }: Zipper<T>): Zipper<T> {\n  return { node: mapValue(fn, node), path }\n}\n\nexport function replace<T> (value: T, zipper : Zipper<T>) : Zipper<T> {\n  return update(() => value, zipper)\n}\n\nexport function tree<T> ({ node }: Zipper<T>) : Node<T> {\n  return node\n}\n\nexport function value<T> ({ node }: Zipper<T>): T {\n  return node.value\n}\n\nexport function goUp<T> ({ node, path }: Zipper<T>): Zipper<T> | undefined {\n  const [context, ...trail] = path\n\n  if (context) {\n    const { focus, left, right } = context\n    const next = { value: focus, children: [...left, node, ...right] }\n    return { node: next, path: trail }\n  } else {\n    return undefined\n  }\n}\n\nexport function goLeft<T> ({ node, path }: Zipper<T>): Zipper<T> | undefined {\n  const [context, ...trail] = path\n\n  if (context) {\n    const { focus, left, right } = context\n    const [nextNode, ...rest] = [...left].reverse()\n\n    if (nextNode) {\n      const nextContext = { focus, left: [...rest].reverse(), right: [node, ...right] }\n      return { node: nextNode, path: [nextContext, ...trail] }\n    } else return undefined\n  } else return undefined\n}\n\nexport function goRight<T> ({ node, path }: Zipper<T>): Zipper<T> | undefined {\n  const [context, ...trail] = path\n\n  if (context) {\n    const { focus, left, right } = context\n    const [nextNode, ...rest] = right\n\n    if (nextNode) {\n      const nextContext = { focus, left: [...left, node], right: rest }\n      return { node: nextNode, path: [nextContext, ...trail] }\n    } else return undefined\n  } else return undefined\n}\n\nexport function goToChild<T> (n: number, { node , path }: Zipper<T>): Zipper<T> | undefined {\n  const { focus, left, right } = indexSplit(n, node.children)\n\n  if (focus) {\n    const context = { focus: node.value, left, right }\n    return { node: focus, path: [context, ...path] }\n  } else return undefined\n}\n\nexport function goToFirstChild<T> (zipper: Zipper<T>): Zipper<T> | undefined {\n  return goToChild(0, zipper)\n}\n\nexport function goToLastChild<T> ({ node, path }: Zipper<T>): Zipper<T> | undefined {\n  return goToChild(node.children.length - 1, { node, path })\n}\n\nfunction goToNextSiblingOfAncestor<T> (zipper: Zipper<T>): Zipper<T> | undefined {\n  const ancestor = goUp(zipper)\n  if (ancestor) {\n    const sibling = goRight(ancestor)\n    if (sibling) return sibling\n    else return goToNextSiblingOfAncestor(ancestor)\n  }\n  else return undefined\n}\n\nexport function goToLastDecendant<T> (zipper: Zipper<T>): Zipper<T> {\n  const child = goToLastChild(zipper)\n  if (child) return goToLastDecendant(child)\n  else return zipper\n}\n\nexport function goNext<T> (zipper: Zipper<T>): Zipper<T> | undefined {\n  return firstOf([goToFirstChild, goRight, goToNextSiblingOfAncestor], zipper)\n}\n\nfunction lastDecendantOfPreviousSibling<T> (zipper: Zipper<T>): Zipper<T> | undefined {\n  const previous = goLeft(zipper)\n  if (previous) return goToLastDecendant(previous)\n  else return undefined\n}\n\nexport function goPrevious<T> (zipper: Zipper<T>): Zipper<T> | undefined {\n  return firstOf([lastDecendantOfPreviousSibling, goUp], zipper)\n}\n\nfunction firstOf<T> (\n  functions: Array<(zipper: Zipper<T>) => Zipper<T> | undefined>,\n  zipper: Zipper<T>\n  ): Zipper<T> | undefined {\n  const [fn, ...rest] = functions\n\n  if (fn) {\n    const step = fn(zipper)\n    if (step) return step\n    else return firstOf(rest, zipper)\n  } else return undefined\n}\n\nfunction indexSplit<T> (\n  n: number,\n  children: Array<Node<T>>\n): {\n  focus: Node<T>,\n  left: Array<Node<T>>,\n  right: Array<Node<T>>\n} {\n  const left = children.slice(0, n)\n  const focus = children[n]\n  const right = children.slice(n + 1)\n\n  return { focus, left, right }\n}\n\nexport function root<T> (zipper: Zipper<T>): Zipper<T> | undefined {\n  if (zipper.path.length > 0) {\n    const up = goUp(zipper)\n    if (up) return root(up)\n    else return undefined\n  } else return zipper\n}\n\nexport function find<T> (\n  predicate: (p: T) => boolean,\n  move: (zipper: Zipper<T>) => Zipper<T> | undefined,\n  zipper: Zipper<T>\n): Zipper<T> | undefined {\n  const next = move(zipper)\n  if (next) {\n    if (predicate(value(next))) return next\n    else return find(predicate, move, next)\n  } else return undefined\n}\n\nexport function findNext<T> (\n predicate: (p: T) => boolean,\n zipper: Zipper<T>\n): Zipper<T> | undefined {\n  return find(predicate, goNext, zipper)\n}\n\nexport function findPrevious<T> (\n  predicate: (p: T) => boolean,\n  zipper: Zipper<T>\n ): Zipper<T> | undefined {\n   return find(predicate, goPrevious, zipper)\n }\n\n export function prepend<T> (\n  prepend: Node<T>,\n  { node, path }: Zipper<T>\n): Zipper<T> {\n  const [context, ...trail] = path\n  let newContext\n  if (context) {\n    const { focus, left, right } = context\n    newContext = { focus, left: [...left, prepend], right }\n  }\n  else newContext = { focus: node.value, left: [prepend], right: [] }\n\n  return { node, path: [newContext, ...trail] }\n}\n\nexport function append<T> (\n  append: Node<T>,\n  { node, path }: Zipper<T>\n): Zipper<T> {\n  const [context, ...trail] = path\n  let newContext\n  if (context) {\n    const { focus, left, right } = context\n    newContext = { focus, left, right: [append, ...right] }\n  }\n  else newContext = { focus: node.value, left: [], right: [append] }\n\n  return { node, path: [newContext, ...trail] }\n}\n\nexport function remove<T> ({ path }: Zipper<T>):  Zipper<T> | undefined {\n  const [context, ...trail] = path\n  if (context) {\n    const { left, right } = context\n    if (right.length) {\n      const [newFocus, ...newRight] = right\n      const newContext = { focus: newFocus.value, left, right: newRight }\n\n      return { node: newFocus, path: [newContext, ...trail] }\n    } else if (left.length) {\n      const newFocus = left[left.length - 1]\n      const newLeft = left.slice(0, -1)\n      const newContext = { focus: newFocus.value, left: newLeft, right }\n\n      return { node: newFocus, path: [newContext, ...trail] }\n    } else {\n      return { node: singleton(trail[0].focus), path: trail }\n    }\n  }\n\n  return undefined\n}"],"mappings":"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","names":["singleton","value","node","children","isLeaf","hasChildren","appendChild","child","prependChild","mapValue","fn","replaceValue","foldr","acc","seed","foldl","a","b","v","foldStep","nodes","sets","cursor","rest","head","tails","count","tree","_value","sum","zipper","node","update","fn","path","mapValue","replace","value","tree","goUp","context","trail","focus","left","right","goLeft","nextNode","rest","nextContext","goRight","goToChild","n","indexSplit","goToFirstChild","goToLastChild","goToNextSiblingOfAncestor","ancestor","sibling","goToLastDecendant","child","goNext","firstOf","lastDecendantOfPreviousSibling","previous","goPrevious","functions","step","children","root","up","find","predicate","move","next","findNext","findPrevious","prepend","newContext","append","remove","newFocus","newRight","newLeft","singleton"]}